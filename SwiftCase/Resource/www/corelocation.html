<!DOCTYPE html>
<html lang="zh-CN" class="">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="renderer" content="webkit"/>
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
    <title>Code</title>
    <link rel="stylesheet" href="./agate.css">
    <script src="./highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<pre><code class="Swift">
å‚è€ƒ https://github.com/woodpower/SwiftCase

import UIKit
import MapKit

class LocationViewController: UIViewController, UISearchBarDelegate, MKMapViewDelegate {

    @IBOutlet weak var mapView: MKMapView!
    
    lazy var geocoder = {
        return CLGeocoder()
    }()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        mapView.userTrackingMode = .followWithHeading // å¸¦å¯¼èˆªçš„å®šä½
        mapView.isRotateEnabled = false
        mapView.mapType = .standard
        
        // è·å–ç”¨æˆ·ä½ç½®
        LocationManager.shared.currentLocation { (location, cityName, error) in
            if let location = location, let cityName = cityName {
                print("\(location.coordinate) \(location.altitude) \(cityName)")
            }
        }
        
    }
    
    // MARK: - MKMapViewDelegate
    // æ·»åŠ æ ‡æ³¨ï¼ˆå¤§å¤´é’ˆï¼‰
    func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {
        // MKUserLocation ç”¨æˆ·å¤§å¤´é’ˆæ ‡è®°ï¼Œä¸æ·»åŠ çš„å¤§å¤´é’ˆåŒºåˆ†å¼€
        if annotation.isKind(of: MKUserLocation.classForCoder()) {
            return nil
        }
        
        let identifier = "pin"
        // å¤ç”¨æœºåˆ¶ï¼Œç±»ä¼¼äºtableview cell
        var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: identifier) as? MKPinAnnotationView
        if annotationView == nil {
            annotationView = MKPinAnnotationView(annotation: annotation, reuseIdentifier: identifier)
            annotationView!.pinTintColor = UIColor.green
            // æ˜¾ç¤ºå¼¹æ¡†
            annotationView!.canShowCallout = true
            annotationView!.leftCalloutAccessoryView = UIImageView(image: UIImage(named: "user_address"))
            annotationView!.rightCalloutAccessoryView = UIImageView(image: UIImage(named: "share_more"))
        } else {
            annotationView!.annotation = annotation
        }
        return annotationView
    }
    
    // è·å–ç”¨æˆ·ä½ç½®
    func mapView(_ mapView: MKMapView, didUpdate userLocation: MKUserLocation) {
        
    }
    
    // ç”»çº¿æ¸²æŸ“ï¼Œçº¿å®½ã€é¢œè‰²
    func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {
        let render = MKPolylineRenderer(overlay: overlay)
        render.lineWidth = 3.0
        render.strokeColor = UIColor.blue
        return render
    }
    
    // MARK: - UISearchBarDelegate
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        searchBar.resignFirstResponder()
        let place = searchBar.text!
        if place.isEmpty {
            return
        }
        getLocation(by: place)
    }
    
    func getLocation(by address: String) {
        geocoder.geocodeAddressString(address) { (placemarks, error) in
            if let placemarks = placemarks {
                self.mapView.removeAnnotations(self.mapView.annotations)
                var latitudeDelta: CLLocationDegrees! = 0.0
                var longitudeDelta: CLLocationDegrees! = 0.0
                
                // å–å¾—ç¬¬ä¸€ä¸ªåœ°æ ‡ï¼Œåœ°æ ‡ä¸­å­˜å‚¨äº†è¯¦ç»†çš„åœ°å€ä¿¡æ¯
                // æ³¨æ„ï¼šä¸€ä¸ªåœ°åå¯èƒ½æœç´¢å‡ºå¤šä¸ªåœ°å€
                for placemark in placemarks {
                    let location = placemark.location // ä½ç½®
                    let region = placemark.region // åŒºåŸŸ
                    let name = placemark.name // åœ°å
                    let country = placemark.country // å›½å®¶
                    let locality = placemark.locality // åŸå¸‚
                    let thoroughfare = placemark.thoroughfare // è¡—é“
                    // let subThoroughfare = placemark.subThoroughfare // è¡—é“ç›¸å…³ä¿¡æ¯ï¼Œä¾‹å¦‚é—¨ç‰Œç­‰
                    // let subLocality = placemark.subLocality // åŸå¸‚ç›¸å…³ä¿¡æ¯ï¼Œä¾‹å¦‚æ ‡å¿—æ€§å»ºç­‘
                    // let administrativeArea = placemark.administrativeArea // å·
                    // let subAdministrativeArea = placemark.subAdministrativeArea // å…¶ä»–è¡Œæ”¿åŒºåŸŸä¿¡æ¯
                    // let postalCode = placemark.postalCode // é‚®ç¼–
                    // let inlandWater = placemark.inlandWater // æ°´æºã€æ¹–æ³Š
                    // let ocean = placemark.ocean // æµ·æ´‹
                    // let areasOfInterest = placemark.areasOfInterest // å…³è”çš„æˆ–åˆ©ç›Šç›¸å…³çš„åœ°æ ‡
                    // let addressInfo = placemark.addressDictionary // è¯¦ç»†åœ°å€ä¿¡æ¯å­—å…¸,åŒ…å«ä»¥ä¸‹éƒ¨åˆ†ä¿¡æ¯
                    
                    print("\(String(describing: location)) \(String(describing: region)) \(String(describing: name))")
                    
                    // 1ã€åˆ›å»ºæ ‡æ³¨å¯¹è±¡
                    let annotation = MKPointAnnotation()
                    
                    // 2ã€è®¾ç½®å±æ€§
                    annotation.coordinate = (placemark.location?.coordinate)!
                    annotation.title = name
                    annotation.subtitle = (country ?? "") + (locality ?? "") + (thoroughfare ?? "")
                    
                    // 3ã€æ·»åŠ åˆ°åœ°å›¾ä¸Š
                    self.mapView.addAnnotation(annotation)
                    
                    if let location = location, let userLocation = self.mapView.userLocation.location {
                        let distance = location.distance(from: userLocation)
                        // è®¾ç½®å­æ ‡é¢˜ï¼Œè·ç¦»æˆ‘çš„ä½ç½®
                        let sub = distance > 1000 ? String(format: "%.2f km", distance / 1000.0) : String(format: "%.0f m", distance)
                        annotation.subtitle = annotation.subtitle! + sub
                        // æ±‚å‡ºè·ç¦»æˆ‘çš„ä½ç½®çš„ç»çº¬åº¦å¢é‡
                        latitudeDelta = max(abs(location.coordinate.latitude - userLocation.coordinate.latitude), latitudeDelta)
                        longitudeDelta = max(abs(location.coordinate.longitude - userLocation.coordinate.longitude), longitudeDelta)
                    }
                }
                // 4ã€å°†æœ€å¤§è·ç¦»ä½œä¸ºä¸­å¿ƒåŒºåŸŸ
                self.mapView.setRegion(MKCoordinateRegion(center: self.mapView.userLocation.coordinate, span: MKCoordinateSpan(latitudeDelta: 2.1 * latitudeDelta, longitudeDelta: 2.1 * longitudeDelta)), animated: true)
            } else {
                print(error.debugDescription)
            }
        }
    }
    
    
    // MARK: - UIEvents
    @IBAction func walk(_ sender: UIButton) {
        if sender.isSelected {
            sender.isSelected = false
            view.showMessage("å¼€å§‹è·‘æ­¥ğŸƒ")
        } else {
            sender.isSelected = true
            view.showMessage("è·‘æ­¥ç»“æŸ")
        }
        
    }
    
    @IBAction func userLocation(_ sender: UIButton) {
        mapView.setCenter(mapView.userLocation.coordinate, animated: true)
    }
    
    
    /// æ ¹æ®èµ·ç‚¹å’Œé‡ç‚¹ç»˜åˆ¶è·¯çº¿
    ///
    /// - Parameters:
    ///   - startMark: èµ·ç‚¹
    ///   - endMark: é‡ç‚¹
    func route(start startMark: CLPlacemark, end endMark: CLPlacemark) {
        // åˆ›å»ºè¯·æ±‚ï¼Œè®¾ç½®èµ·ç‚¹å’Œé‡ç‚¹
        let request = MKDirectionsRequest()
        request.source = MKMapItem(placemark: MKPlacemark(placemark: startMark))
        request.destination = MKMapItem(placemark: MKPlacemark(placemark: endMark))
        
        // æ ¹æ®è¯·æ±‚ä¿¡æ¯ï¼Œè®¡ç®—å‡ºè·¯çº¿
        let direction = MKDirections(request: request)
        direction.calculate { (response, error) in
            if let response = response {
                for route in response.routes {
                    print("Distance: %.2f km Time: %.1f h", route.distance / 1000.0, route.expectedTravelTime / 3600)
                    // è½¬æŠ˜ç‚¹è¿çº¿æ·»åŠ åˆ°åœ°å›¾ä¸­
                    for step in route.steps {
                        self.mapView.add(step.polyline)
                    }
                }
            }
        }
        
    }

}


////////////////////////////////////////////////////////////////////////////////////////////////////

typealias LocationBlock = (_ location: CLLocation?, _ cityName: String?, _ error: Error?) -> Void

class LocationManager: NSObject, CLLocationManagerDelegate {
    
    static let shared = LocationManager()
    
    private var mgr: CLLocationManager!
    
    private var geocoder: CLGeocoder!
    
    private var location: LocationBlock?
    
    var cityName: String?
    
    override init() {
        super.init()
        mgr = CLLocationManager()
        // è®¾ç½®å®šä½ç²¾åº¦
        mgr.desiredAccuracy = kCLLocationAccuracyBest
        // å®šä½é¢‘ç‡,æ¯éš”å¤šå°‘ç±³å®šä½ä¸€æ¬¡
//        mgr.distanceFilter = 10.0
        mgr.delegate = self
        geocoder = CLGeocoder()
    }
    
    func currentLocation(_ location: @escaping LocationBlock) {
        // è¯·æ±‚æˆæƒ
        mgr.requestWhenInUseAuthorization()
        // å¼€å§‹å®šä½
        mgr.startUpdatingLocation()
        // å…ˆä¿å­˜ï¼Œå½“è·å–åˆ°ä½ç½®æ—¶å›è°ƒ
        self.location = location
    }
    
    // æ ¹æ®åœ°åç¡®å®šåœ°ç†åæ ‡
    func placemarks(searchBy address: String, _ completionHandler: @escaping (_ placemarks: [CLPlacemark]) -> Void) -> Void {
        geocoder.geocodeAddressString(address) { (placemarks, error) in
            if let placemarks = placemarks {
                completionHandler(placemarks)
            } else {
                print(error.debugDescription)
            }
        }
    }
    
    // MARK: - CLLocationManagerDelegate
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        switch status {
        case .authorizedAlways, .authorizedWhenInUse:
            if let _ = self.location {
                manager.startUpdatingLocation()
            }
        default:
            print("ç”¨æˆ·æœªæˆæƒå®šä½")
        }
    }
    
    // æˆåŠŸè·å–ä½ç½®åå›è°ƒå½“å‰ä½ç½®ä¿¡æ¯
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if let locationBlock = self.location, let location = locations.last {
            // åå‘åœ°ç†ç¼–ç è·å–åŸå¸‚åç§°
            geocoder.reverseGeocodeLocation(location, completionHandler: { (placemarks, error) in
                // å–å¾—ç¬¬ä¸€ä¸ªåœ°æ ‡ï¼Œåœ°æ ‡ä¸­å­˜å‚¨äº†è¯¦ç»†çš„åœ°å€ä¿¡æ¯
                // æ³¨æ„ï¼šä¸€ä¸ªåœ°åå¯èƒ½æœç´¢å‡ºå¤šä¸ªåœ°å€ï¼Œå–ç¬¬ä¸€ä¸ªè¾ƒä¸ºç²¾ç¡®
                if let info = placemarks?.first?.addressDictionary {
                    self.cityName = info["City"] as? String
                    locationBlock(location, self.cityName, nil)
                }
            })
        }
        manager.stopUpdatingLocation()
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        if let location = self.location {
            location(nil, nil, error)
        }
        manager.stopUpdatingLocation()
    }
    
    
    
}

</code></pre>
</body>
</html>
